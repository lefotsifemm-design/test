# requirements.txt
# aiogram==3.*
# aioschedule==0.7.1
# python-dotenv

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict

import aioschedule
from aiogram import Bot, Dispatcher, Router, F
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove, CallbackQuery
from aiogram.utils.keyboard import ReplyKeyboardBuilder
from dotenv import load_dotenv
import os

load_dotenv()
TOKEN = os.getenv("BOT_TOKEN")          # â† Ğ²Ğ°Ñˆ Ñ‚Ğ¾ĞºĞµĞ½
ADMIN_ID = int(os.getenv("ADMIN_ID", 0))  # Ğ²Ğ°Ñˆ telegram id Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode

bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#              Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºÑƒÑ€ÑĞ¾Ğ² (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ² Ğ‘Ğ”)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
COURSES = {
    "python_basic": {
        "name": "Python Ñ Ğ½ÑƒĞ»Ñ",
        "next_date": "2026-02-10 18:30",
        "places_left": 8,
        "price": "4 900 â‚½"
    },
    "python_pro": {
        "name": "Python Pro (ĞĞĞŸ + FastAPI)",
        "next_date": "2026-02-17 19:00",
        "places_left": 5,
        "price": "9 900 â‚½"
    },
    "data_science": {
        "name": "Data Science. Ğ¡Ñ‚Ğ°Ñ€Ñ‚",
        "next_date": "2026-03-01 17:00",
        "places_left": 12,
        "price": "14 900 â‚½"
    }
}

# Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğµ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹ (Ğ² Ğ¿Ñ€Ğ¾Ğ´Ğ°ĞºÑˆĞµĞ½Ğµ â†’ SQLite / PostgreSQL)
bookings: Dict[int, dict] = {}   # user_id â†’ {"course": "...", "date": "...", "name": "...", "phone": "..."}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ FSM
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class BookingForm(StatesGroup):
    choosing_course = State()
    name = State()
    phone = State()
    confirm = State()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                 Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_main_kb() -> ReplyKeyboardMarkup:
    builder = ReplyKeyboardBuilder()
    builder.add(KeyboardButton(text="ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° ĞºÑƒÑ€Ñ"))
    builder.add(KeyboardButton(text="ğŸ“‹ ĞœĞ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸"))
    builder.add(KeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸"))
    builder.add(KeyboardButton(text="ğŸ’³ Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ±Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹"))
    builder.adjust(2)  # Ğ¿Ğ¾ Ğ´Ğ²Ğµ Ğ² Ñ€ÑĞ´
    return builder.as_markup(resize_keyboard=True)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                 Ğ¡Ñ‚Ğ°Ñ€Ñ‚ / Ğ¼ĞµĞ½Ñ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.message(CommandStart())
async def cmd_start(message: Message):
    text = (
        "Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ±Ğ¾Ñ‚ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½Ğ° ĞºÑƒÑ€ÑÑ‹! ğŸ“\n\n"
        "Ğ—Ğ´ĞµÑÑŒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾:\n"
        "â€¢ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¸ Ğ·Ğ°Ğ±Ñ€Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¼ĞµÑÑ‚Ğ¾ Ğ½Ğ° ĞºÑƒÑ€Ñ\n"
        "â€¢ Ğ¿Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑĞ²Ğ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸\n"
        "â€¢ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ° ÑÑƒÑ‚ĞºĞ¸ Ğ´Ğ¾ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ°\n\n"
        "<i>Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½Ğ¸Ğ¶Ğµ â†“</i>"
    )
    await message.answer(text, reply_markup=get_main_kb())

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #                 Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ±Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @router.message(F.text == "ğŸ’³ Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ±Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹")
    async def payment_info(message: Message):
        text = (
            "ğŸ’³ <b>Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ±Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹</b>\n\n"
            "ĞĞ¿Ğ»Ğ°Ñ‚Ğ° Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ¿Ğ¾ÑĞ»Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½Ğ° ĞºÑƒÑ€Ñ.\n\n"
            "Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹:\n"
            "â€¢ ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñƒ Ğ¡Ğ±ĞµÑ€Ğ° / Ğ¢Ğ¸Ğ½ÑŒĞºĞ¾Ñ„Ñ„ (Ñ€ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹ Ğ¿Ñ€Ğ¸ÑˆĞ»Ñ Ğ¿Ğ¾ÑĞ»Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸)\n"
            "â€¢ ĞŸĞ¾ ÑÑ‡Ñ‘Ñ‚Ñƒ Ğ´Ğ»Ñ ÑÑ€.Ğ»Ğ¸Ñ†\n"
            "â€¢ Ğ§ĞµÑ€ĞµĞ· Ğ®Kassa / CloudPayments (ÑÑÑ‹Ğ»ĞºĞ° Ğ½Ğ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñƒ)\n"
            "â€¢ ĞšÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ğ° USDT (TRC20/BEP20)\n\n"
            "ĞŸĞ¾ÑĞ»Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ Ğ²Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸Ğ°Ğ»Ğ°Ğ¼.\n"
            "Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ â€” Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ ÑÑĞ´Ğ°!"
        )
        await message.answer(text, reply_markup=get_main_kb())

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #                 ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class CancelForm(StatesGroup):
        confirm = State()

    @router.message(F.text == "âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸")
    async def start_cancel(message: Message, state: FSMContext):
        user_id = message.from_user.id
        if user_id not in bookings:
            await message.answer("Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹.", reply_markup=get_main_kb())
            return

        b = bookings[user_id]
        await state.update_data(booking_to_cancel=b)

        kb = ReplyKeyboardBuilder()
        kb.add(KeyboardButton(text="âœ… Ğ”Ğ°, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ"))
        kb.add(KeyboardButton(text="ğŸ”™ ĞĞµÑ‚, Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ"))
        kb.adjust(1)

        text = (
            "Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ?\n\n"
            f"ĞšÑƒÑ€Ñ: {b['course']}\n"
            f"Ğ”Ğ°Ñ‚Ğ°: {b['date']}\n\n"
            "ĞŸĞ¾ÑĞ»Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ¼ĞµÑÑ‚Ğ¾ Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ´Ğ»Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ…."
        )
        await message.answer(text, reply_markup=kb.as_markup(resize_keyboard=True))
        await state.set_state(CancelForm.confirm)

    @router.message(CancelForm.confirm, F.text == "âœ… Ğ”Ğ°, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ")
    async def confirm_cancel(message: Message, state: FSMContext):
        data = await state.get_data()
        b = data["booking_to_cancel"]
        user_id = message.from_user.id

        # ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµĞ¼ Ğ¼ĞµÑÑ‚Ğ¾
        for slug, course in COURSES.items():
            if course["name"] == b["course"]:
                course["places_left"] += 1
                break

        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ
        bookings.pop(user_id, None)

        await message.answer("âœ… Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°!", reply_markup=get_main_kb())
        await state.clear()

        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
        if ADMIN_ID:
            await bot.send_message(
                ADMIN_ID,
                f"âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸!\n"
                f"ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: {message.from_user.full_name} (@{message.from_user.username or 'Ğ½ĞµÑ‚'})\n"
                f"ĞšÑƒÑ€Ñ: {b['course']}\n"
                f"Ğ”Ğ°Ñ‚Ğ°: {b['date']}\n"
                f"Ğ˜Ğ¼Ñ: {b['name']}\n"
                f"ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚: {b['phone']}"
            )

    @router.message(CancelForm.confirm, F.text == "ğŸ”™ ĞĞµÑ‚, Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ")
    async def decline_cancel(message: Message, state: FSMContext):
        await message.answer("ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¿Ñ€ĞµÑ€Ğ²Ğ°Ğ½Ğ°. Ğ’Ğ°ÑˆĞ° Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ°.", reply_markup=get_main_kb())
        await state.clear()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                 ĞœĞ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.message(F.text == "ĞœĞ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸")
async def my_bookings(message: Message):
    user_id = message.from_user.id
    if user_id not in bookings:
        await message.answer("Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹.")
        return

    b = bookings[user_id]
    text = (
        "<b>Ğ’Ğ°ÑˆĞ° Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ:</b>\n\n"
        f"ĞšÑƒÑ€Ñ: {b['course']}\n"
        f"Ğ”Ğ°Ñ‚Ğ°: {b['date']}\n"
        f"Ğ˜Ğ¼Ñ: {b['name']}\n"
        f"ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚: {b['phone']}"
    )
    await message.answer(text)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#              ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ñ (ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 5 Ğ¼Ğ¸Ğ½ÑƒÑ‚ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def send_reminders():
    now = datetime.now()
    tomorrow = now + timedelta(hours=23)   # Ğ·Ğ° ~24 Ñ‡Ğ°ÑĞ°

    to_remove = []
    for uid, b in bookings.items():
        try:
            dt = datetime.fromisoformat(b["date"].replace(" ", "T"))
            if tomorrow < dt < tomorrow + timedelta(minutes=70):
                await bot.send_message(
                    uid,
                    f"ğŸ”” <b>ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ!</b>\n\n"
                    f"Ğ—Ğ°Ğ²Ñ‚Ñ€Ğ° Ğ² {b['date']} Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚ÑÑ ĞºÑƒÑ€Ñ\n"
                    f"<b>{b['course']}</b>\n"
                    "ĞĞµ Ğ·Ğ°Ğ±ÑƒĞ´ÑŒÑ‚Ğµ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ ğŸ˜‰"
                )
                logger.info(f"ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {uid}")
                # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ°Ğº "Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ½Ğ¸Ğ»Ğ¸" Ğ¸ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¶Ğµ
                to_remove.append(uid)
        except Exception as e:
            logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ñ {uid}: {e}")

    for uid in to_remove:
        bookings.pop(uid, None)


async def scheduler():
    aioschedule.every(5).minutes.do(send_reminders)
    while True:
        await aioschedule.run_pending()
        await asyncio.sleep(1)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                 Ğ—Ğ°Ğ¿ÑƒÑĞº
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def main():
    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ webhook, ĞµÑĞ»Ğ¸ Ğ¾Ğ½ Ğ±Ñ‹Ğ» ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ñ€Ğ°Ğ½ÑŒÑˆĞµ
    await bot.delete_webhook(drop_pending_updates=True)

    asyncio.create_task(scheduler())  # Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº
    await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())

if __name__ == "__main__":
    asyncio.run(main())